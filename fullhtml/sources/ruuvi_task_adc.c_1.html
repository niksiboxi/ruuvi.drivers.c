
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ruuvi_task_adc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1"> </a>
<a name="ln2">/**</a>
<a name="ln3"> * @addtogroup adc_tasks</a>
<a name="ln4"> */</a>
<a name="ln5">/*@{*/</a>
<a name="ln6">/**</a>
<a name="ln7"> * @file rt_adc.c</a>
<a name="ln8"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln9"> * @date 2019-11-28</a>
<a name="ln10"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln11"> */</a>
<a name="ln12">#include &quot;ruuvi_driver_enabled_modules.h&quot;</a>
<a name="ln13">#if RT_ADC_ENABLED</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;ruuvi_task_adc.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;stdbool.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln21">#include &quot;ruuvi_driver_sensor.h&quot;</a>
<a name="ln22">#include &quot;ruuvi_interface_adc_mcu.h&quot;</a>
<a name="ln23">#include &quot;ruuvi_interface_atomic.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#define RD_ADC_USE_DIVIDER      1.00f</a>
<a name="ln26">#define RD_ADC_USE_VDD          3.30f</a>
<a name="ln27"> </a>
<a name="ln28">#define RD_ADC_DATA_COUNTER     1</a>
<a name="ln29">#define RD_ADC_DATA_START       0</a>
<a name="ln30"> </a>
<a name="ln31">#define RD_ADC_DEFAULT_BITFIELD 0</a>
<a name="ln32">#define RD_ADC_CLEAN_BYTE       0</a>
<a name="ln33">#define RD_ADC_INIT_BYTE        0</a>
<a name="ln34"> </a>
<a name="ln35">#define RT_ADC_CH_UNUSED        (0xFFU) //!&lt; Channel not assigned.</a>
<a name="ln36"> </a>
<a name="ln37">static ri_atomic_t m_is_init;</a>
<a name="ln38">static bool m_is_configured;</a>
<a name="ln39">static bool m_vdd_prepared;</a>
<a name="ln40">static bool m_vdd_sampled;</a>
<a name="ln41">static bool m_ratio;</a>
<a name="ln42">static float m_vdd;</a>
<a name="ln43">static uint8_t m_handle; //!&lt; handle of last ADC used.</a>
<a name="ln44">static uint8_t m_channel[RI_ADC_CH_NUM]; //!&lt; Channel assigment for handles.</a>
<a name="ln45">static uint8_t m_next_channel; //!&lt; Next channel to be assigned.</a>
<a name="ln46"> </a>
<a name="ln47">/**</a>
<a name="ln48"> * @brief assign ADC channel for a handle</a>
<a name="ln49"> *</a>
<a name="ln50"> * @retval RD_SUCCESS If channel was assigned or handle already has channel.</a>
<a name="ln51"> * @retval RD_ERROR_RESOURCES If there are no channels available.</a>
<a name="ln52"> * @retval RD_ERROR_INVALID_PARAM If</a>
<a name="ln53"> */</a>
<a name="ln54">static rd_status_t channel_assign (const uint8_t handle)</a>
<a name="ln55">{</a>
<a name="ln56">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln57"> </a>
<a name="ln58">    if (handle &gt; RI_ADC_CH_NUM)</a>
<a name="ln59">    {</a>
<a name="ln60">        err_code |= RD_ERROR_INVALID_PARAM;</a>
<a name="ln61">    }</a>
<a name="ln62">    else if (RT_ADC_CH_UNUSED == m_channel[handle])</a>
<a name="ln63">    {</a>
<a name="ln64">        if (ri_adc_mcu_is_valid_ch (m_next_channel))</a>
<a name="ln65">        {</a>
<a name="ln66">            m_channel[handle] = m_next_channel++;</a>
<a name="ln67">        }</a>
<a name="ln68">        else</a>
<a name="ln69">        {</a>
<a name="ln70">            err_code |= RD_ERROR_RESOURCES;</a>
<a name="ln71">        }</a>
<a name="ln72">    }</a>
<a name="ln73">    else</a>
<a name="ln74">    {</a>
<a name="ln75">        // No action needed.</a>
<a name="ln76">    }</a>
<a name="ln77"> </a>
<a name="ln78">    return err_code;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">static ri_adc_pins_config_t pins_config =</a>
<a name="ln83">{</a>
<a name="ln84">    .p_pin.channel = RI_ADC_AINVDD,</a>
<a name="ln85">#ifdef RI_ADC_ADV_CONFIG</a>
<a name="ln86">    .p_pin.resistor = RI_ADC_RESISTOR_DISABLED,</a>
<a name="ln87">#endif</a>
<a name="ln88">};</a>
<a name="ln89"> </a>
<a name="ln90">static ri_adc_channel_config_t absolute_config =</a>
<a name="ln91">{</a>
<a name="ln92">    .mode = RI_ADC_MODE_SINGLE,</a>
<a name="ln93">    .vref = RI_ADC_VREF_INTERNAL,</a>
<a name="ln94">#ifdef RI_ADC_ADV_CONFIG</a>
<a name="ln95">    .gain = RI_ADC_GAIN1_6,</a>
<a name="ln96">    .acqtime = RI_ADC_ACQTIME_10US,</a>
<a name="ln97">#endif</a>
<a name="ln98">};</a>
<a name="ln99"> </a>
<a name="ln100">static ri_adc_get_data_t options =</a>
<a name="ln101">{</a>
<a name="ln102">    .vdd = RD_ADC_USE_VDD,</a>
<a name="ln103">    .divider = RD_ADC_USE_DIVIDER,</a>
<a name="ln104">};</a>
<a name="ln105"> </a>
<a name="ln106">static rd_status_t rt_adc_mcu_data_get (rd_sensor_data_t * const</a>
<a name="ln107">                                        p_data)</a>
<a name="ln108">{</a>
<a name="ln109">    rd_status_t status = RD_ERROR_INVALID_STATE;</a>
<a name="ln110"> </a>
<a name="ln111">    if (NULL == p_data)</a>
<a name="ln112">    {</a>
<a name="ln113">        status = RD_ERROR_NULL;</a>
<a name="ln114">    }</a>
<a name="ln115">    else</a>
<a name="ln116">    {</a>
<a name="ln117">        p_data-&gt;timestamp_ms = RD_UINT64_INVALID;</a>
<a name="ln118">        rd_sensor_data_t d_adc;</a>
<a name="ln119">        rd_sensor_data_fields_t adc_fields = {.bitfield = RD_ADC_DEFAULT_BITFIELD};</a>
<a name="ln120">        float adc_values[RD_ADC_DATA_COUNTER];</a>
<a name="ln121"> </a>
<a name="ln122">        if (false == m_ratio)</a>
<a name="ln123">        {</a>
<a name="ln124">            status = ri_adc_get_data_absolute (m_channel[m_handle],</a>
<a name="ln125">                                               &amp;options,</a>
<a name="ln126">                                               &amp;adc_values[RD_ADC_DATA_START]);</a>
<a name="ln127">        }</a>
<a name="ln128">        else</a>
<a name="ln129">        {</a>
<a name="ln130">            status = ri_adc_get_data_ratio (m_channel[m_handle],</a>
<a name="ln131">                                            &amp;options,</a>
<a name="ln132">                                            &amp;adc_values[RD_ADC_DATA_START]);</a>
<a name="ln133">        }</a>
<a name="ln134"> </a>
<a name="ln135">        if (RD_SUCCESS == status)</a>
<a name="ln136">        {</a>
<a name="ln137">            adc_fields.datas.voltage_v = RD_ADC_DATA_COUNTER;</a>
<a name="ln138">            d_adc.data = adc_values;</a>
<a name="ln139">            d_adc.valid  = adc_fields;</a>
<a name="ln140">            d_adc.fields = adc_fields;</a>
<a name="ln141">            rd_sensor_data_populate (p_data,</a>
<a name="ln142">                                     &amp;d_adc,</a>
<a name="ln143">                                     p_data-&gt;fields);</a>
<a name="ln144">            p_data-&gt;timestamp_ms = rd_sensor_timestamp_get();</a>
<a name="ln145">        }</a>
<a name="ln146">    }</a>
<a name="ln147"> </a>
<a name="ln148">    return RD_SUCCESS;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">rd_status_t rt_adc_init (void)</a>
<a name="ln152">{</a>
<a name="ln153">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln154"> </a>
<a name="ln155">    if (!ri_atomic_flag (&amp;m_is_init, true))</a>
<a name="ln156">    {</a>
<a name="ln157">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln158">    }</a>
<a name="ln159">    else</a>
<a name="ln160">    {</a>
<a name="ln161">        for (size_t ii = 0; ii &lt; RI_ADC_CH_NUM; ii++)</a>
<a name="ln162">        {</a>
<a name="ln163">            m_channel[ii] = RT_ADC_CH_UNUSED;</a>
<a name="ln164">        }</a>
<a name="ln165"> </a>
<a name="ln166">        m_next_channel = 0;</a>
<a name="ln167">        err_code |= ri_adc_init (NULL);</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    return err_code;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">rd_status_t rt_adc_uninit (void)</a>
<a name="ln174">{</a>
<a name="ln175">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln176">    m_is_configured = false;</a>
<a name="ln177">    m_vdd_prepared = false;</a>
<a name="ln178">    m_vdd_sampled = false;</a>
<a name="ln179">    m_ratio = false;</a>
<a name="ln180">    err_code |= ri_adc_stop (m_channel[m_handle]);</a>
<a name="ln181">    err_code |= ri_adc_uninit (true);</a>
<a name="ln182"> </a>
<a name="ln183">    for (size_t ii = 0; ii &lt; RI_ADC_CH_NUM; ii++)</a>
<a name="ln184">    {</a>
<a name="ln185">        m_channel[ii] = RT_ADC_CH_UNUSED;</a>
<a name="ln186">    }</a>
<a name="ln187"> </a>
<a name="ln188">    m_next_channel = 0;</a>
<a name="ln189"> </a>
<a name="ln190">    if (!ri_atomic_flag (&amp;m_is_init, false))</a>
<a name="ln191">    {</a>
<a name="ln192">        err_code |= RD_ERROR_FATAL;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">    return err_code;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">inline bool rt_adc_is_init (void)</a>
<a name="ln199">{</a>
<a name="ln200">    return (RD_ADC_INIT_BYTE != m_is_init);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">rd_status_t rt_adc_configure_se (rd_sensor_configuration_t * const config,</a>
<a name="ln204">                                 const uint8_t handle, const rt_adc_mode_t mode)</a>
<a name="ln205">{</a>
<a name="ln206">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln207"> </a>
<a name="ln208">    if (!rt_adc_is_init() || m_is_configured)</a>
<a name="ln209">    {</a>
<a name="ln210">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln211">    }</a>
<a name="ln212">    else if (RI_ADC_GND == handle)</a>
<a name="ln213">    {</a>
<a name="ln214">        err_code |= RD_ERROR_INVALID_PARAM;</a>
<a name="ln215">    }</a>
<a name="ln216">    else</a>
<a name="ln217">    {</a>
<a name="ln218">        pins_config.p_pin.channel = handle;</a>
<a name="ln219"> </a>
<a name="ln220">        if (ABSOLUTE == mode)</a>
<a name="ln221">        {</a>
<a name="ln222">            m_ratio = false;</a>
<a name="ln223">        }</a>
<a name="ln224">        else</a>
<a name="ln225">        {</a>
<a name="ln226">            m_ratio = true;</a>
<a name="ln227">        }</a>
<a name="ln228"> </a>
<a name="ln229">        // Handle is used as channel index, however there is NONE at index 0.</a>
<a name="ln230">        m_handle = handle;</a>
<a name="ln231">        err_code |= channel_assign (m_handle);</a>
<a name="ln232"> </a>
<a name="ln233">        if (RD_SUCCESS == err_code)</a>
<a name="ln234">        {</a>
<a name="ln235">            err_code |= ri_adc_configure (m_channel[m_handle],</a>
<a name="ln236">                                          &amp;pins_config,</a>
<a name="ln237">                                          &amp;absolute_config);</a>
<a name="ln238">        }</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    if (RD_SUCCESS == err_code)</a>
<a name="ln242">    {</a>
<a name="ln243">        m_is_configured = true;</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    return err_code;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">rd_status_t rt_adc_sample (void)</a>
<a name="ln250">{</a>
<a name="ln251">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln252"> </a>
<a name="ln253">    if (!rt_adc_is_init() || !m_is_configured)</a>
<a name="ln254">    {</a>
<a name="ln255">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">    return err_code;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">rd_status_t rt_adc_voltage_get (rd_sensor_data_t * const data)</a>
<a name="ln262">{</a>
<a name="ln263">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln264"> </a>
<a name="ln265">    if (!rt_adc_is_init() || !m_is_configured)</a>
<a name="ln266">    {</a>
<a name="ln267">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln268">    }</a>
<a name="ln269">    else</a>
<a name="ln270">    {</a>
<a name="ln271">        if (true == m_ratio)</a>
<a name="ln272">        {</a>
<a name="ln273">            err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln274">        }</a>
<a name="ln275">        else</a>
<a name="ln276">        {</a>
<a name="ln277">            err_code |= rt_adc_mcu_data_get (data);</a>
<a name="ln278">        }</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    return err_code;</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">rd_status_t rt_adc_ratio_get (rd_sensor_data_t * const data)</a>
<a name="ln285">{</a>
<a name="ln286">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln287"> </a>
<a name="ln288">    if (!rt_adc_is_init() || !m_is_configured)</a>
<a name="ln289">    {</a>
<a name="ln290">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln291">    }</a>
<a name="ln292">    else</a>
<a name="ln293">    {</a>
<a name="ln294">        if (false == m_ratio)</a>
<a name="ln295">        {</a>
<a name="ln296">            err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln297">        }</a>
<a name="ln298">        else</a>
<a name="ln299">        {</a>
<a name="ln300">            err_code |= rt_adc_mcu_data_get (data);</a>
<a name="ln301">        }</a>
<a name="ln302">    }</a>
<a name="ln303"> </a>
<a name="ln304">    return err_code;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">rd_status_t rt_adc_vdd_prepare (rd_sensor_configuration_t * const vdd_adc_configuration)</a>
<a name="ln308">{</a>
<a name="ln309">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln310">    err_code |= rt_adc_init();</a>
<a name="ln311">    err_code |= rt_adc_configure_se (vdd_adc_configuration, RI_ADC_AINVDD,</a>
<a name="ln312">                                     ABSOLUTE);</a>
<a name="ln313">    m_vdd_prepared = (RD_SUCCESS == err_code);</a>
<a name="ln314">    return err_code;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">rd_status_t rt_adc_vdd_sample (void)</a>
<a name="ln318">{</a>
<a name="ln319">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln320"> </a>
<a name="ln321">    if (!m_vdd_prepared)</a>
<a name="ln322">    {</a>
<a name="ln323">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln324">    }</a>
<a name="ln325">    else</a>
<a name="ln326">    {</a>
<a name="ln327">        rd_sensor_data_t battery;</a>
<a name="ln328">        memset (&amp;battery, RD_ADC_CLEAN_BYTE, sizeof (rd_sensor_data_t));</a>
<a name="ln329">        float battery_values;</a>
<a name="ln330">        battery.data = &amp;battery_values;</a>
<a name="ln331">        battery.fields.datas.voltage_v = RD_ADC_DATA_COUNTER;</a>
<a name="ln332">        err_code |= rt_adc_voltage_get (&amp;battery);</a>
<a name="ln333">        m_vdd = rd_sensor_data_parse (&amp;battery, battery.fields);</a>
<a name="ln334">        err_code |= rt_adc_uninit();</a>
<a name="ln335">        m_vdd_prepared = false;</a>
<a name="ln336">        m_vdd_sampled = true;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">    return err_code;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">rd_status_t rt_adc_vdd_get (float * const battery)</a>
<a name="ln343">{</a>
<a name="ln344">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln345"> </a>
<a name="ln346">    if (true == m_vdd_sampled)</a>
<a name="ln347">    {</a>
<a name="ln348">        *battery = m_vdd;</a>
<a name="ln349">    }</a>
<a name="ln350">    else</a>
<a name="ln351">    {</a>
<a name="ln352">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln353">    }</a>
<a name="ln354"> </a>
<a name="ln355">    return err_code;</a>
<a name="ln356">}</a>
<a name="ln357">#endif</a>
<a name="ln358">/*@}*/</a>

</code></pre>
<div class="balloon" rel="58"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '>' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="62"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'handle' index could reach 10.</p></div>
<div class="balloon" rel="66"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'handle' index could reach 10.</p></div>
<div class="balloon" rel="122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'Boolean'.</p></div>
<div class="balloon" rel="137"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="161"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '(0xFFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="177"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="178"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="183"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '(0xFFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="188"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="200"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '!=' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="218"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the 'handle' expression should not be converted from the essential 'unsigned' type to the essential 'ri_adc_channel_t' type.</p></div>
<div class="balloon" rel="218"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'ri_adc_channel_t' and 'unsigned'.</p></div>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="243"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="203"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'config'.</p></div>
<div class="balloon" rel="271"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'Boolean'.</p></div>
<div class="balloon" rel="294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'Boolean'.</p></div>
<div class="balloon" rel="331"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="335"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="336"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'Boolean' and 'signed'.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'Boolean'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
